package sports.model.repository

import com.mongodb.MongoClient
import com.mongodb.ServerAddress
import com.mongodb.client.MongoCollection
import de.bwaldvogel.mongo.MongoServer
import de.bwaldvogel.mongo.backend.memory.MemoryBackend
import org.bson.codecs.configuration.CodecRegistries.fromProviders
import org.bson.codecs.configuration.CodecRegistries.fromRegistries
import org.bson.codecs.pojo.PojoCodecProvider
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.litote.kmongo.eq
import org.litote.kmongo.findOne
import org.litote.kmongo.getCollection
import sports.model.*

//consts

private const val SPORT_1_NAME = "sport1"
private const val SPORT_2_NAME = "sport2"
private const val SPORT_3_NAME = "sport3"
private const val NON_PRESENT_NAME = "another name"
private const val DATABASE_NAME = "testdb"

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class SportsMongoDBTest {

    //in memory database to simulate a mongo db for testing purposes
    private var pojoCodecRegistry = fromRegistries(
        MongoClient.getDefaultCodecRegistry(),
        fromProviders(PojoCodecProvider.builder().automatic(true).build())
    )
    private val server = MongoServer(MemoryBackend())
    private val client = MongoClient(ServerAddress(server.bind()))
    private var collection: MongoCollection<Sport> =
        client.getDatabase(DATABASE_NAME).withCodecRegistry(pojoCodecRegistry).getCollection()

    //SUT
    private val sportsMongoDB: SportsMongoDB = SportsMongoDB(collection)

    //model's classes
    private lateinit var sports: List<Sport>
    private lateinit var sport1: Sport
    private lateinit var sport2: Sport
    private lateinit var sport3: Sport

    private lateinit var schedule1: Schedule
    private lateinit var schedule2: Schedule
    private lateinit var schedule3: Schedule
    private lateinit var schedule4: Schedule
    private lateinit var schedule5: Schedule
    private lateinit var schedule6: Schedule
    private lateinit var schedule7: Schedule
    private lateinit var anotherSchedule: Schedule

    private lateinit var schedulesForSport1: List<Schedule>
    private lateinit var schedulesForSport2: List<Schedule>
    private lateinit var schedulesForSport3: List<Schedule>

    @BeforeAll
    fun initBeforeAll() {
        //setup for a set of model's objects to populate the database

        //we donÂ´t mock the classes from the model package because the database will fully interact with them, so we should
        //mock every method, including constructors, getters and setters autogenerated by kotlin for the classes, and the same for the classes
        //that every one depends on. This would be add unnecessary boilerplate code for simple classes whom only act as a data containers
        //and were already tested in separate classes
        schedule1 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.MONDAY)
        schedule2 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.TUESDAY)
        schedule3 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.WEDNESDAY)
        schedule4 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.THURSDAY)
        schedule5 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.MONDAY)
        schedule6 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.TUESDAY)
        schedule7 = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.WEDNESDAY)
        anotherSchedule = Schedule(Time(ANY_HOUR, ANY_MIN), Time(ANY_HOUR, ANY_MIN), Day.FRIDAY)

        schedulesForSport1 = listOf(schedule1, schedule2)
        schedulesForSport2 = listOf(schedule3, schedule4, schedule5, schedule6, schedule7)
        schedulesForSport3 = listOf()

        sport1 = Sport(SPORT_1_NAME, schedulesForSport1)
        sport2 = Sport(SPORT_2_NAME, schedulesForSport2)
        sport3 = Sport(SPORT_3_NAME, schedulesForSport3)
    }

    @BeforeEach
    fun initBeforeEach() {
        collection.drop()
    }

    //configurations for the database
    private fun initDB(vararg sportsList: Sport) {
        sports = sportsList.asList()
        collection.insertMany(sports)
    }


    //Tests

    @Nested
    inner class TestsForGetters {

        @Nested
        inner class TestsForGetAll {
            @Test
            fun `getAll() with an one sport's database`() {
                //init
                initDB(sport1)

                //tests
                assertEquals(sports, sportsMongoDB.getAll())
            }

            @Test
            fun `getAll() from a bunch of sports`() {
                //init
                initDB(sport1, sport2, sport3)

                //tests
                val returnedList = sportsMongoDB.getAll()
                assertEquals(sports, returnedList)
            }


            @Test
            fun `getAll() with an empty database`() {
                //tests
                assertEquals(listOf<Sport>(), sportsMongoDB.getAll())
            }
        }

        @Nested
        inner class TestsForGetSport {
            @Test
            fun `getSport() for the first sport`() {
                //init
                initDB(sport1, sport2, sport3)

                //tests
                assertEquals(sport1, sportsMongoDB.getSport(SPORT_1_NAME).get())
            }

            @Test
            fun `getSport() for the last sport`() {
                //init
                initDB(sport1, sport2, sport3)

                //tests
                assertEquals(sport3, sportsMongoDB.getSport(SPORT_3_NAME).get())
            }

            @Test
            fun `getSport() for the only sport`() {
                //init
                initDB(sport1)

                //tests
                assertEquals(sport1, sportsMongoDB.getSport(SPORT_1_NAME).get())
            }

            @Test
            fun `getSport() for an empty database`() {
                //tests
                assert(!sportsMongoDB.getSport(SPORT_1_NAME).isPresent)
            }

            @Test
            fun `getSport() for a non present sport`() {
                //init
                initDB(sport1, sport2, sport3)
                val name = NON_PRESENT_NAME

                //tests
                assert(!sportsMongoDB.getSport(name).isPresent)
            }
        }

        @Nested
        inner class TestsForGetSchedules {
            @Test
            fun `getSchedules() from a present sport`() {
                //init
                initDB(sport1, sport2, sport3)

                //tests
                assertEquals(schedulesForSport2, sportsMongoDB.getSchedules(SPORT_2_NAME).get())
            }

            @Test
            fun `getSchedules() from a sport without schedules`() {
                //init
                initDB(sport1, sport2, sport3)

                //tests
                assertEquals(listOf<Schedule>(), sportsMongoDB.getSchedules(SPORT_3_NAME).get())
            }


            @Test
            fun `getSchedules() from a non-present sport`() {
                //tests
                assert(!sportsMongoDB.getSchedules(NON_PRESENT_NAME).isPresent)
            }
        }

    }

    @Nested
    inner class TestsForAdds {
        @Nested
        inner class TestsForAddSport {

            @Test
            fun `addSport() to an empty database`() {
                //test
                sportsMongoDB.addSport(sport1)
                assertEquals(collection.find().toList().size, 1)
                assertEquals(collection.findOne(Sport::sportName eq SPORT_1_NAME), sport1)
            }

            @Test
            fun `addSport() to a non-empty database`() {
                //init
                initDB(sport1)
                //test
                sportsMongoDB.addSport(sport2)
                assertEquals(collection.find().toList().size, 2)
                assertEquals(collection.findOne(Sport::sportName eq SPORT_2_NAME), sport2)
            }

            @Test
            fun `addSport() duplicated`() {
                //init
                initDB(sport1)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.addSport(sport1) }
            }

            @Test
            fun `addSport() with duplicated name`() {
                //init
                initDB(sport1)
                //test
                val newSport = Sport(SPORT_1_NAME, schedulesForSport1)
                assertThrows<IllegalArgumentException> { sportsMongoDB.addSport(newSport) }
            }
        }

        @Nested
        inner class TestsForAddSchedule {

            @Test
            fun `addSchedule() to an empty database`() {
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.addSchedule(SPORT_1_NAME, schedule1) }
            }

            @Test
            fun `addSchedule() to a database which not contains the specified sport`() {
                //init
                initDB(sport1)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.addSchedule(SPORT_2_NAME, schedule1) }
            }

            @Test
            fun `addSchedule() duplicated for a given sport`() {
                //init
                initDB(sport1)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.addSchedule(SPORT_1_NAME, schedule1) }
            }

            @Test
            fun `addSchedule() for a given sport who already have some schedules`() {
                //init
                initDB(sport1, sport2, sport3)
                //test
                sportsMongoDB.addSchedule(SPORT_2_NAME, anotherSchedule)
                assert(collection.findOne(Sport::sportName eq SPORT_2_NAME)!!.schedules.contains(anotherSchedule))
            }
        }
    }

    @Nested
    inner class TestsForRemoves {
        @Nested
        inner class TestsForRemoveSport {

            @Test
            fun `removeSport() from an empty database`() {
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.removeSport(SPORT_1_NAME) }
            }

            @Test
            fun `removeSport() from a database which not contains the specified sport`() {
                //init
                initDB(sport1)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.removeSport(SPORT_2_NAME) }
            }

            @Test
            fun `removeSport() from a database which includes it`() {
                //init
                initDB(sport1, sport2, sport3)
                //test
                assert(collection.find().toList().contains(sport2))
                sportsMongoDB.removeSport(SPORT_2_NAME)
                assert(!collection.find().toList().contains(sport2))
            }
        }

        @Nested
        inner class TestsForRemoveSchedule() {
            @Test
            fun `removeSchedule() from an empty database`() {
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.removeSchedule(SPORT_1_NAME, schedule1) }
            }

            @Test
            fun `removeSchedule() to a database which not contains the specified sport`() {
                //init
                initDB(sport1)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.removeSchedule(SPORT_2_NAME, schedule1) }
            }

            @Test
            fun `removeSchedule() from an existing sport which has the given schedule`() {
                //init
                initDB(sport1, sport2, sport3)
                //test
                assert(sport1.schedules.contains(schedule2))
                sportsMongoDB.removeSchedule(SPORT_1_NAME, schedule2)
                assert(!collection.findOne(Sport::sportName eq SPORT_1_NAME)!!.schedules.contains(schedule2))
            }

            @Test
            fun `removeSchedule() for a given sport which doesn't contains the given schedule`() {
                //init
                initDB(sport1, sport2, sport3)
                //test
                assertThrows<IllegalArgumentException> { sportsMongoDB.removeSchedule(SPORT_2_NAME, anotherSchedule) }
            }
        }
    }

    @AfterAll
    fun tearDown() {
        client.close()
        server.shutdown()
    }

}